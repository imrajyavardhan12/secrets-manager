import { existsSync, readFileSync, writeFileSync, chmodSync, renameSync, unlinkSync } from 'fs';
import { randomBytes } from 'crypto';
import { dirname, join, basename } from 'path';
import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';
import type { ProjectConfig, UserConfig } from '../types/index.js';
import { FILE_PERMISSIONS, PROJECT_CONFIG_FILE, GITIGNORE_FILE, ENV_FILE } from '../utils/constants.js';
import { ensureDirectory } from './database.js';

export function fileExists(filePath: string): boolean {
  return existsSync(filePath);
}

export function readFile(filePath: string): string {
  return readFileSync(filePath, 'utf-8');
}

export function writeFile(filePath: string, content: string, mode?: number): void {
  ensureDirectory(dirname(filePath));
  writeFileAtomic(filePath, content, mode ?? FILE_PERMISSIONS.CONFIG);
}

export function writeFileAtomic(filePath: string, content: string, mode: number): void {
  const tempPath = `${filePath}.${randomBytes(6).toString('hex')}.tmp`;
  try {
    writeFileSync(tempPath, content, { mode });
    try {
      chmodSync(tempPath, mode);
    } catch {
      // Ignore permission errors on some systems
    }
    renameSync(tempPath, filePath);
  } catch (err) {
    try {
      unlinkSync(tempPath);
    } catch {
      // Ignore cleanup errors
    }
    throw err;
  }
}

export function loadProjectConfig(projectPath: string): ProjectConfig | null {
  const configPath = join(projectPath, PROJECT_CONFIG_FILE);
  if (!fileExists(configPath)) {
    return null;
  }

  const content = readFile(configPath);
  return parseYaml(content) as ProjectConfig;
}

export function saveProjectConfig(projectPath: string, config: ProjectConfig): void {
  const configPath = join(projectPath, PROJECT_CONFIG_FILE);
  const content = stringifyYaml(config);
  writeFile(configPath, content, FILE_PERMISSIONS.PROJECT_CONFIG);
}

export function loadUserConfig(configPath: string): UserConfig | null {
  if (!fileExists(configPath)) {
    return null;
  }

  const content = readFile(configPath);
  return JSON.parse(content) as UserConfig;
}

export function saveUserConfig(configPath: string, config: UserConfig): void {
  const content = JSON.stringify(config, null, 2);
  writeFile(configPath, content, FILE_PERMISSIONS.CONFIG);
}

export function updateGitignore(projectPath: string): boolean {
  const gitignorePath = join(projectPath, GITIGNORE_FILE);
  const entriesToAdd = ['.env', '.env.*', '!.env.example'];
  
  let content = '';
  let modified = false;

  if (fileExists(gitignorePath)) {
    content = readFile(gitignorePath);
  }

  const lines = content.split('\n');

  for (const entry of entriesToAdd) {
    if (!lines.some(line => line.trim() === entry)) {
      if (content && !content.endsWith('\n')) {
        content += '\n';
      }
      content += entry + '\n';
      modified = true;
    }
  }

  if (modified) {
    writeFile(gitignorePath, content, FILE_PERMISSIONS.PROJECT_CONFIG);
  }

  return modified;
}

export function writeEnvFile(projectPath: string, secrets: Record<string, string>, environment: string): void {
  const envPath = join(projectPath, ENV_FILE);
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);

  let content = `# Generated by secrets-manager on ${timestamp}\n`;
  content += `# Environment: ${environment}\n`;
  content += '# DO NOT COMMIT THIS FILE\n\n';

  for (const [key, value] of Object.entries(secrets)) {
    const escapedValue = value.includes(' ') || value.includes('"') || value.includes("'")
      ? `"${value.replace(/"/g, '\\"')}"`
      : value;
    content += `${key}=${escapedValue}\n`;
  }

  writeFile(envPath, content, FILE_PERMISSIONS.ENV_FILE);
}

export function findProjectRoot(startPath: string): string | null {
  let currentPath = startPath;

  while (currentPath !== dirname(currentPath)) {
    if (fileExists(join(currentPath, PROJECT_CONFIG_FILE))) {
      return currentPath;
    }
    if (fileExists(join(currentPath, '.git'))) {
      return currentPath;
    }
    if (fileExists(join(currentPath, 'package.json'))) {
      return currentPath;
    }
    currentPath = dirname(currentPath);
  }

  return null;
}

export function getProjectName(projectPath: string): string {
  const packageJsonPath = join(projectPath, 'package.json');
  
  if (fileExists(packageJsonPath)) {
    try {
      const pkg = JSON.parse(readFile(packageJsonPath));
      if (pkg.name) {
        return pkg.name;
      }
    } catch {
      // Fall through to directory name
    }
  }

  return basename(projectPath);
}

export function detectEnvironmentFromGit(projectPath: string): string | null {
  const gitHeadPath = join(projectPath, '.git', 'HEAD');
  
  if (!fileExists(gitHeadPath)) {
    return null;
  }

  try {
    const content = readFile(gitHeadPath);
    const match = content.match(/ref: refs\/heads\/(.+)/);
    
    if (match) {
      const branch = match[1].trim();
      
      if (branch === 'main' || branch === 'master' || branch === 'production') {
        return 'prod';
      }
      if (branch === 'staging' || branch === 'stage') {
        return 'staging';
      }
      if (branch === 'develop' || branch === 'development' || branch === 'dev') {
        return 'dev';
      }
    }
  } catch {
    // Ignore errors
  }

  return null;
}

export function detectEnvironment(projectPath: string): string {
  const nodeEnv = process.env.NODE_ENV;
  if (nodeEnv) {
    if (['production', 'prod'].includes(nodeEnv)) return 'prod';
    if (['staging', 'stage'].includes(nodeEnv)) return 'staging';
    if (['development', 'dev'].includes(nodeEnv)) return 'dev';
  }

  const gitEnv = detectEnvironmentFromGit(projectPath);
  if (gitEnv) {
    return gitEnv;
  }

  return 'dev';
}
